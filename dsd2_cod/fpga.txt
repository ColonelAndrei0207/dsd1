/*
fpga modlue - incapsulates the modules used in the RISC PC

it contains the UART driver, memory controller, memory and RISC core,

*/


module fpga(
	
	//sys interface (clk and reset)
	input logic sys_clk_i,
	input logic sys_reset_n_i,
	
	//connections with the PC
	input logic rx_i,
	output logic tx_o,
	output logic interrupt_o
	
	);
	
	logic risc_clk_gate_s;
	logic risc_rst_n_s;
	//axi interface
	axi_lite_interface axi_if;

    //interconection wires
    
    //mem_ctrl with data_mem
    logic mem_ctrl_data_we;
    logic [ `D_BITS-1: 0 ] mem_ctrl_data_out_s;
    logic [ `D_BITS-1: 0 ] mem_ctrl_data_in_s;   
    logic [ `A_BITS-1: 0 ] mem_ctrl_data_addr_s; 
    
    //mem_ctrl with instruction mem
    logic [ `A_SIZE-1:0 ] mem_ctrl_instr_s;
    logic mem_ctrl_instr_we_s;
    logic [ `A_BITS-1:0] mem_ctrl_instr_addr_s;
    
    logic [ `RISC_FLAG_NR-1:0 ] risc_flags_s; 
    
    //memories with RISC core
    logic [ `A_SIZE-1:0 ] instr_risc_s;
    logic risc_read_s;
    logic risc_write_s;
    logic [ `D_BITS-1 : 0 ] risc_data_in_s;
    logic [ `D_BITS-1 : 0 ] risc_data_out_s;
    logic [ `A_BITS-1 : 0 ] risc_addr_s; 
    logic [ `A_BITS-1 : 0 ] risc_pc_s;
    
    
    //MUX output wires
    
    //DATA + addr MUX
    logic [ `D_BITS-1: 0 ] mem_data_out_s;
    logic [ `D_BITS-1: 0 ] mem_data_in_s;
    logic [ `A_BITS-1: 0 ] mem_addr_s;
    
    
    //WriteEnable MUX
    logic mem_data_we_s;
    
    //InstrAddr MUX
    logic [ `A_BITS-1 : 0 ] mem_instr_addr_s;
    
    //AND output for the RISC clock signal
    logic risc_clk_s;
    
    //assignation of the sys signals
    assign axi_if.a_clk = sys_clk_i;
    assign axi_if.a_reset_n = sys_reset_n_i;
	
//UART Driver SLAVE

       axi_uartlite_0 UART_driver (
       
       .* //pray it is ok
       
       );

//mem_ctrl MASTER
mem_ctrl ctrl_inst(
	
	.axi_if(axi_if.master),

	.risc_flags_o(risc_flags_s),
	.data_in_i(mem_ctrl_data_in_s),

	.data_out_o(mem_ctrl_data_out_s),
	.addr_out_o(mem_ctrl_data_addr_s),
	.data_we(mem_ctrl_data_we),


	.instr_addr_out_o(mem_ctrl_instr_addr_s),
	.instr_out_o(mem_ctrl_instr_s),
	.instr_we(mem_ctrl_instr_we_s)	
	);


//MUX that transfers the data+address from data_mem either to mem_ctrl or to RISC core (to fufill data_in_i of mem_ctrl
always_comb begin

    mem_data_out_s = 0;
    mem_data_in_s = 0;
        
    if( risc_read_s | risc_write_s ) begin //if the RISC core comunicates with data mem
    
        mem_data_out_s = risc_data_in_s; //the output of the data mem will link to the data input of RISC
        mem_data_in_s = risc_data_out_s; //the input of the data mem will link to the data output of the RISC
        mem_addr_s = risc_addr_s; //address of the RISC will link to the address input of the data mem
    
    end
    else begin //else it means that the mem_ctrl will communicate with the data mem
    
        mem_data_out_s = mem_ctrl_data_in_s;
        mem_data_in_s = mem_ctrl_data_out_s;        
        mem_addr_s = mem_ctrl_data_addr_s;
        
    end

end

//MUX that enables the writing/reading into data_mem, either from mem_ctrl or from RISC
always_comb begin

    mem_data_we_s = 0;
    
    if ( risc_write_s ) begin
    
        mem_data_we_s = risc_write_s;
    
    end
    else if ( risc_read_s ) begin
    
        mem_data_we_s = ~risc_read_s;
        
    end
    else begin
    
        mem_data_we_s = mem_ctrl_data_we;
        
    end
end

//block that generates the HALT,START,STOP signals for the RISC core
always_ff @( posedge sys_clk_i, negedge sys_reset_n_i  ) begin //TODO: think about the HALT and RESET commands

	if(!sys_reset_n_i) begin
		
		risc_clk_gate_s <= 0;
		
	end
	else begin
	
		if(risc_flags_s == `START_FLAG) begin
			
			risc_clk_gate_s <= 1;
		
		end
		else if(risc_flags_s == `HALT_FLAG) begin
			
			risc_clk_gate_s <= 0;
		
		end
		else if(risc_flags_s == `RESET_FLAG) begin
			
			risc_clk_gate_s <= 1;
		
		end
	end
	
end

//MUX that controls the addr of instruction_mem (either ProgramCounter or addr from mem_ctrl)
always_comb begin

    mem_instr_addr_s = 0;
	
	if(risc_flags_s == `START_FLAG) begin
		
		mem_instr_addr_s = risc_pc_s;
	
	end
	else begin
		
		mem_instr_addr_s = mem_ctrl_instr_addr_s;
	
	end
end


//AND gate that generates the RISC clock signal, when we receive START from the mem_ctrl

assign risc_clk_s = sys_clk_i & risc_clk_gate_s;

//TODO: think about how to reset the RISC when asked by the mem_ctrl assign risc_rst_n_s = 

data_mem data_mem_inst(

		.we(mem_data_we_s),
		
		.clk_i(sys_clk_i),
		.rst_n_i(sys_reset_n_i),
		.data_in_i(mem_data_in_s),
		.addr_i(mem_ctrl_data_addr_s),
		.data_out_o(mem_data_out_s)

    );
    
program_mem program_mem_inst (
		
		.clk_i(sys_clk_i),
		.rst_n_i(sys_reset_n_i),
		.we(mem_ctrl_instr_we_s),
		.instr_i(mem_ctrl_instr_s),
		.instr_addr_i(mem_instr_addr_s),
		.instr_o(instr_risc_s)

    );
	

procesor risc_core_inst (

		// general
		.rst_i(risc_rst_n_s),   // active 0
		.clk_i(risc_clk_s),
		// program memory
		.pc_o(risc_pc_s),
		.instruction_i(instr_risc_s),
		// data memory
		.read_o(risc_read_s),  // active 1
		.write_o(risc_write_s), // active 1
		.address_o(risc_addr_s),
		.data_in_i(risc_data_in_s),
		.data_out_o(risc_data_out_s)

    );

endmodule
	
